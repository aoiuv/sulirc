本文来由，笔者之前看过 redux 的源码，对于中间件组合的实现原理这一部分会有所迷惑

这一段代码来源于 redux 里导出的 compose 函数。我做了一些修改。主要是给匿名函数添加了名称，比如 reducer 和 nextWrapper，主要原因是匿名函数（anonymous）不便于调试。所以 《You-Dont-Know-JS》 的作者 Kyle Simpson 大叔就对箭头函数持保留意见，认为不该乱用，不过跑题了，扯回。

先贴代码如下。

```js
function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function reducer(a, b) {
    return function nextWrapper(...args) {
      return a(b(...args));
    };
  });
}
```

接下来全文将基于此函数剖析。

接下来将提供几个简单 redux 中间件，同样，我避免了箭头函数的使用，理由同上。代码如下：

```js
function next(action) {
  console.log("[next]", action);
}

function fooMiddleware(next) {
  console.log("[fooMiddleware] trigger");
  return function next_from_foo(action) {
    console.log("[fooMiddleware] before next");
    next(action);
    console.log("[fooMiddleware] after next");
  };
}

function barMiddleware(next) {
  console.log("[barMiddleware] trigger");
  return function next_from_bar(action) {
    console.log("[barMiddleware] before next");
    next(action);
    console.log("[barMiddleware] after next");
  };
}

function bazMiddleware(next) {
  console.log("[bazMiddleware] trigger");
  return function next_from_baz(action) {
    console.log("[bazMiddleware] before next");
    next(action);
    console.log("[bazMiddleware] after next");
  };
}
```

此时如果将以上 foo bar baz 三个中间件组合运行如下：

```js
const chain = compose(fooMiddleware, barMiddleware, bazMiddleware);
const nextChain = chain(next);
nextChain("{data}");
```

以上将会在控制台输出什么？

大家可以思考一下。

...

熟悉中间件运行顺序的同学可能很快得出答案：

```
[bazMiddleware] trigger
[barMiddleware] trigger
[fooMiddleware] trigger
[fooMiddleware] before next
[barMiddleware] before next
[bazMiddleware] before next
[next] {data}
[bazMiddleware] after next
[barMiddleware] after next
[fooMiddleware] after next
```

写不出正确答案的同学也无须灰心。这篇文章的目的，正是帮助大家更好理解这一套机制原理。

这种洋葱模型，也即是中间件的能力之强大众所周知，现在在 Web 社区发挥极大作用的 Redux、Express、Koa，开发者利用其中的洋葱模型，构建无数强大又有趣的 Web 应用和 Node 应用。更不用提基于这三个衍生出来的 Dva、Egg 等。 所以其实需要理解的是这套实现机制原理，如果光是记住中间件执行顺序，未免太过无趣了，现在让我们逐层逐层解构以上代码来探索洋葱模型吧。

到这里，正文正式开始！

以上代码的灵魂之处在于 Array.prototype.reduce()，不了解此函数的同学强烈建议去 MDN 遛跶一圈 [MDN | Array.prototype.reduce()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)。

reduce 函数是函数式编程的一个重要概念，可用于实现函数组合（compose）

## reduce 组合中间件

```js
const chain = compose(fooMiddleware, barMiddleware, bazMiddleware);
```

以上 compose 传入了 fooMiddleware、barMiddleware、bazMiddleware 三个中间件进行组合，内部执行步骤可以分解为以下两步。

1. 第一步输入参数：a -> fooMiddleware，b -> barMiddleware

执行 reduce 第一个循环，得到返回输出：nextWrapper(...args) { return fooMiddleware(barMiddleware(...args)) }

2. 第二步输入参数：a -> nextWrapper(...args) { return fooMiddleware(barMiddleware(...args)) }，b -> bazMiddleware

执行 reduce 第二个循环，得到返回输出：chain = (...args) => fooMiddleware(barMiddleware(bazMiddleware(...args)))。

## 作为 Monkeypatching 的 next 参数

然而此时请留意，所有中间件并没有执行，到目前为止最终通过高阶函数 nextWrapper 返回了出来而已。

因为直到以下这一句，传入 next 函数作为参数，才开始真正的触发了 nextWrapper，开始迭代执行所有组合过的中间件。

```js
const nextChain = chain(next);
```

我们在上面得知了 chain 最终是形如(...args) => fooMiddleware(barMiddleware(bazMiddleware(...args)))的函数。因此当传入 next 函数时，内部执行步骤可以分为以下三步：

1. 第一步，执行 chain 函数，从 compose 的函数组合从内至外，next 参数首先交由 bazMiddleware 函数执行，打印日志后，返回了函数 next_from_baz。

2. 第二步，因此，barMiddleware 函数接收的期望 next 参数，其实并不是我们一开始的 next 函数了，而是 bazMiddleware 函数执行后返回的 next_from_baz。barMiddleware 收到 next 参数开始执行，打印日志后，返回了 next_from_bar 函数。

3. 第三步，同理，fooMiddleware 函数接收的期望 next 参数是 barMiddleware 函数执行后返回的 next_from_bar。fooMiddleware 收到 next 参数开始执行，打印日志并返回了 next_from_foo 函数。

所以此时我们此时可知，运行完 chain 函数后，实际上 chain 函数就是 next_from_foo 函数。

作为 redux 参考，这个 next 函数其实就是 redux 中的 dispatch 函数。

## 洋葱模型

```js
nextChain("{data}");
```
