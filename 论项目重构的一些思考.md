谈一谈项目重构的思考

## 微内核

微封装、隔离稳定与不稳定、单一职责、明确边界

## 事件钩子 - 生命周期

如何细分生命周期的粒度？
是否需要拦截功能？

## 中间件 - 增加处理与拦截机制

什么情况下需要中间件？

## 状态管理 - 维护应用状态

如何进行模型分类管理？

## 插件注册 - 提供第三方扩展

插件之间的冲突，变量的竞争？

## 适配器 - 版本兼容

## 单元测试

----

# 二版设计 @enow/enow-live
# 现状分析
liveSDK存在前期设计不合理，存在以下问题：
1. 需求迭代中扩展功能容易影响稳定模块（业务模型脏耦合在核心逻辑，没有形成稳定的依赖方向）
2. SDK的API设计受历史版本限制，无法进行升级
3. 同步“拉模型”机制在并发场景下不够高效
4. 缺乏状态管理方案，状态混乱，难以维护

因此针对上述问题，希望在梳理现有模块和需求的基础上，有计划的设计一个符合SRP、OCP的基础框架。*允许SDK向后兼容，并可以更稳定的方式迭代新版本*。

# 需求分析
经过对过往需求进行梳理与分析，目前针对互动需求主要可以归类为以下三种。

### 组件扩展
基于上层业务场景，或者不合理的功能分配，引发的组件扩展需求，操作liveSDK的addon DOM层进行组件实现，在render入口进行渲染。

示例1：因业务需求，定制消息组件、工具栏组件，但与核心业务逻辑无关。

### 配置扩展
基于enow、mis的已存在或新增的配置项组合和补充，满足业务需求。

示例1：不同对接方对于主题有不同需求，云课堂定制暗色主题，是通过透传enow配置项features.theme实现。

### SDK扩展
基于enow、mis的已存在的API组合和补充，满足业务需求。这种场景比较多，属于高频需求场景。

示例1：录播需求的插入图片接口，其实是在liveSDK中进行参数计算后，调用enow暴露sendAction的element.common.add事件实现。云课堂插入视频、录播的插入批注、插入课件页同理。
示例2：元素互动本身作为主逻辑，其实也是基于enow、ms实现，也属于SDK扩展。
示例3：模型同步同元素互动，最大区别在于需要加上状态管理。

# 设计目标
1. Histoy模型改推为拉
2. 简化元素行为数据处理流程（生产、转化、消费）
3. 引入状态管理方案
4. 隔离互动核心代码（稳定）与业务需求（不稳定）
依赖方向：`enow、ms、store <— core <— plugin <— adapter`

[image:460839E2-974E-467F-80CD-D59D78955592-299-000041113CBDCB89/image2019-11-25_16-29-42.png]


Core模块应该作为liveSDK中最稳定的模块，支撑上层业务。
Plugin模块作为业务具体实现，每个Plugin之间互不干扰，同时只依赖Core模块，将单个Plugin部署的影响降至最低。
Adapter模块作为SDK兼容入口，也即是最不稳定的模块，与对应的业务Plugin，一起作为主要测试模块。

# 分层一：内核 Core
设计core的目标主要在于将稳定的，最重要的核心逻辑抽离，与业务完全解耦。作为底层模块支持上层业务实现，同时不受上层业务逻辑影响。

需设计：
* 需要设计生命周期
* 插件注册机制
* 统一的事件通知机制
* 对enow、ms、store服务的微封装

[image:B34C4AB2-AE70-471E-971D-F33F91344FF1-299-0000411722A866D4/image2019-11-25_17-13-3.png]


core的生命周期（简化版）：
`beforeConfig → afterConfig → beforeConnect → afterConnect → beforeRender → afterRender → destory`

core代理 enow/ms/store 大部分核心事件
`core.on(event, handler)`
`core.emit(event, data)`

core注册插件
`core.use(plugin)`

core的状态变更、获取、通知
`core.store.dispatch()`
`core.store.getState()`
`core.store.onStateChange(state) / core.on(‘onStateChange’, handler)`

# 分层二：插件 Plugin
每一个业务Plugin继承自通用Plugin，对应特定的业务需求进行实现，注册到core上。
通过core的插件注册机制，动态插入不同的生命周期，通过修改上下文（配置，core的事件通知、enow、ms、store），达成插件需求。
￼
[image:9F7ACDF0-E117-4229-AA07-7908A7E5D13F-299-0000411BC7A6C64D/image2019-11-25_19-0-49.png]

[image:FCF74C24-1974-48C0-B2B1-5B3348074113-299-0000411DD25A1771/image2019-11-25_18-45-19.png]

`plugin.apply(context)`中声明自己的model，管理该plugin的状态。
`pulgin.execute(…args)`可执行自己的方法。再通过adapter代理此方法到实际业务中。
`plugin.on[lifeCycle](context)`除了上述的生命周期之外，可以实现对应的enow生命周期，粒度更细。

# 分层三：适配器 Adapter
设计Adapter的目标在于，集中版本SDK向下兼容。为了可以迭代设计更合理、良好的SDK，而不用担心版本兼容问题，必须把脏活都丢在最外层，也即是Adapter。

[image:53DA25C0-DBAD-4E18-832A-955C88C4E890-299-000041208E846E89/image2019-11-25_18-54-51.png]

过时的API可以给予legacy提示，促使第三方接入时接入新的API语法。

# 总结
经过重新设计后，存在以下优点：
1. 推模型可减轻多端并发同步的压力
2. 简化元素数据处理逻辑，更易于定位问题
3. 引入redux集中管理应用状态，可接入redux-devtools观察应用状态变化。
4. 插件（业务需求）与核心互动逻辑完全解耦，极大减少因迭代开发引发的代码衰败和互相干扰。
5. 插件（业务需求）可动态插拔，更灵活。
6. 与互动逻辑弱相关的插件（业务需求）可委托第三方实现，通过core提供的use(plugin)机制注册使用（比如主题）
7. 核心Core模块稳定后，不同插件可以由对应的同学开发，开发成本更低。

# 问题
1. 插件之间存在上下文干扰，如何排除影响？
2. 是否存在比插件更佳的形式？

[image:D400345B-E3B1-42D6-A7CE-EA616664C073-299-000046102E2746E7/A33ABB90-8E77-4858-9F6F-8372B08AEFB5.png]


#design-note
