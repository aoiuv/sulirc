## 前言

> 正则表达式是用于匹配字符串中字符组合的模式

正则，毋庸置疑，是一个无比强大的工具。如果仔细留意，我们可以在源代码（各种语言）、编辑器、开发者工具、命令行等地方看到正则的身影。学习使用正则，不仅有趣，也是提升工作效率的一条捷径。

所以，让我们深入学习正则吧~

备注：文章将用大量图例来演示正则，而文章末尾会介绍正则的实践与应用。

## 创建正则

比如说我们想匹配以下字符串中的单词 Hello world

```js
const string = `Hello world_2019/09/19 22:50:53`;
```

我们有以下两种方式创建正则，如下。

### 字面量

一般常使用正则表达式字面量方式定义正则，适用于当正则表达式保持不变的场景。

```js
const regex = /([a-z]+\s?){2}/i;
```

如图所示：

![](https://user-gold-cdn.xitu.io/2019/9/19/16d4a1905fb769fe?w=914&h=380&f=png&s=33954)

### 构造函数

构造函数方式定义正则，提供运行时编译，适用于正则表达式来源不确定，或者动态变化组成的情况，但性能表现差于字面量定义方式。

比如上述例子可以改写为以下构造函数方式，但需要留意的是，转义字符需要多加一个斜杠进行反转义。

```js
const regex = new RegExp("([a-z]+\\s?)".repeat(2), "i");
```

在控制台可以看出：

![](https://user-gold-cdn.xitu.io/2019/9/19/16d4a1b343c1d8db?w=1022&h=142&f=png&s=26097)

## 基础概念

正则的常用概念可以参考下表，主要熟记字符类型、锚点、转义字符、量词等。

![](https://user-gold-cdn.xitu.io/2019/9/19/16d4a189b0cfba5b?w=734&h=1378&f=png&s=216973)

基础用法相信大家都很快理解，以下重点介绍贪婪、分组、断言、查找等。

## 贪婪与非贪婪

? 如果紧跟在任何量词 \*、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符）。

而我们默认的是贪婪模式，即匹配尽可能多的字符。如下图：

![](https://user-gold-cdn.xitu.io/2019/9/19/16d4a2d69d5b5335?w=738&h=408&f=png&s=33181)

可以看到，我们匹配了尽可能多的除换行符之外的任意字符。

而加个?后，改写成非贪婪模式：

![](https://user-gold-cdn.xitu.io/2019/9/19/16d4a2f576720d14?w=810&h=424&f=png&s=34664)

则发现，只匹配了一个字符后，即停止。

## 断言与查找

### 正先行断言

模式：x(?=y)

匹配出 x 表达式，但 x 后面必须跟着 y 表达式。

![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d12f189a9bea?w=684&h=372&f=png&s=21771)

### 负先行断言

模式：x(?!y)

匹配出 x 表达式，但 x 后面不能跟着 y 表达式。

![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d13a99b86879?w=642&h=382&f=png&s=22109)

### 正后发断言

模式：(?<=y)x

相当明显，匹配出 x 表达式，但 x 前必须出现 y 表达式。

![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d14cb1e5704c?w=900&h=376&f=png&s=24985)

### 负后发断言

模式：(?<!y)x

相当明显，匹配出 x 表达式，但 x 前不能出现 y 表达式。

![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d1566a2e6d50?w=878&h=382&f=png&s=25167)

### \1

\1 其实就是上一个匹配到分组引用。

比如我要在 I like JJLin and Huahua~ 中匹配 Huahua，如图：

![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d18942a7e69a?w=740&h=366&f=png&s=22599)

当然以下方式也可达成：

1. 使用量词 + 或 \*
   ![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d1a6ef109d30?w=758&h=370&f=png&s=22379)

2. 或者用全局搜索标志 g
   ![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d1b768a7ccbf?w=650&h=372&f=png&s=20743)

3. 使用范围 {2}

![](https://user-gold-cdn.xitu.io/2019/9/20/16d4d1d1e30c04b8?w=794&h=370&f=png&s=24323)

不过，虽然条条大路通罗马，但还是需要注意匹配的 hua 数量。比如方法 1、2 都会尽可能多的匹配。

## 使用正则

### JavaScript

#### RegExp 对象

##### 正则表达式方法

- RegExp.prototype.exec()
- RegExp.prototype.test()

##### 正则表达式静态属性

- RegExp.$1-$9
- RegExp.input (\$\_)
- RegExp.lastMatch (\$&)
- RegExp.lastParen (\$+)
- RegExp.leftContext (\$`)

具体使用方法可参考 MDN 文档

#### String 对象

##### replace

一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。

##### match

一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。

##### matchAll

一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。

##### search

一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。

##### split

一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。

### 编辑器

#### 查找

#### 替换

### 浏览器

console filter

### 命令行

这里主要介绍命令行中最常用的文本处理工具 grep。（除此之外还有 sed、awk）。grep 全名为"Global search Regular Expression and Print out the line"。

见名思义，grep 可以与正则结合进行文本匹配。

假设我们有文本如下：

```bash
$ cat tinytext
apple yummy
appear angle
and wisper: "ANGLE"
```

我们想要匹配 angle 单词的行

```bash
$ grep "angle" tinytext
appear angle
```

成功！

如果我们想要忽略大小写敏感，可以加上 "-i" 或者 "--ignore-case" 选项。（默认 grep 是大小写敏感）。

```bash
$ grep -i "angle" tinytext
appear angle
and wisper: "ANGLE"
```

许多时候，我们并不想匹配行，而想匹配关键字，此时可以加上 "-o" 或则 "--only-matching" 选项。

```bash
$ grep -io "angle" tinytext
angle
ANGLE
```

以上我们都只是普通文本匹配，grep 支持基本正则表达式，我们可以使用 "-E" 或者 ”"--extended-regexp" 选项使用扩展正则表达式。

比如我们想匹配出 yummy 前的单词，我稍微一考虑，就写出以下规则：匹配至少大于一个 a-z 字符组成的，并且后面必须跟着一个空格及 yummy 的一个单词。

```bash
$ grep -oE "[a-z]+(?=\syummy)" tinytext
grep: repetition-operator operand invalid
```

但是，不幸的发现失败了。经过一番查找，发现 grep 默认不支持 "?=" 操作符。但是不要急，在 mac 系统中可以通过通过以下命令升级我们的工具箱。

```bash
$ brew insall grep
...
...
All commands have been installed with the prefix "g".
```

于是我们获得了 ggrep，然后可以加上 "-P" 或者 "--perl-regexp" 使用兼容 Perl 的正则引擎。

```bash
$ ggrep -oP "[a-z]+(?=\syummy)" tinytext
apple
```

成功了！

相信经常用命令行处理工具的同学都会认可 grep 的实用性（前端同学可能比较陌生，但是建议学习）

### 匹配 ifconfig 中的 ip 地址

笔者有个困扰，经常开发项目的时候需要知道自己笔记本的 ip 地址。这时候我会敲入 ifconfig 然后肉眼一顿搜索，每次都得浪费几秒，才能找到 ip 地址。

此时 grep 命令发挥了作用

```bash
$ ifconfig | ggrep -oP "(?<=inet\s)\d{1,3}(\.\d{1,3}){3}"
127.0.0.1
192.168.31.254
```

噌噌噌！简简单单~我们可以将其配置为 bash 别名 `alias get-ip='ifconfig | ggrep -oP "(?<=inet\s)\d{1,3}(\.\d{1,3}){3}"'`，这里不介绍。我之前的博客有提到。

```bash
$ get-ip
127.0.0.1
192.168.31.254
```

### 匹配对应端口的 node 应用程序进程 PID

比如我们需要寻找端口 8001 的 node 应用程序进程 PID。

我们通过命令 `lsof -i tcp:8001`

```bash
$ lsof -i tcp:8001
COMMAND   PID        USER   FD   TYPE            DEVICE SIZE/OFF NODE NAME
node    87701 yanguangjie   23u  IPv6 0x42c450e30b40bcb      0t0  TCP *:vcom-tunnel (LISTEN)
```

使用 grep 匹配出 node 应用程序 PID。

```bash
$ lsof -i tcp:8001 | ggrep -oP "(?:node[^\d]+)\d+(?=\s)" | egrep -o "\d+"
87701
```

要问匹配 PID 出来有什么用？当然是强制杀掉它了！

```bash
$ kill -9 $(lsof -i tcp:8001 | ggrep -oP "(?:node[^\d]+)\d+(?=\s)" | egrep -o "\d+")
```

正则语法规则参考文档：https://www.regular-expressions.info/refquick.html

## 小结

到此为止，也只是比较肤浅的介绍了一下正则。正则是实践性极强的一门工具，或者说是艺术也不为过。多上手练习和使用，相信还是能起很大作用的。

以上，如果助益，不胜荣幸。

## 参考资料

- [Learn regex the easy way](https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md)
- [Regular_Expressions | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)
- [awesome-regex](https://github.com/aloisdg/awesome-regex)
- [regexr](https://regexr.com/)
- [regexpr](https://regexper.com/)
