## 背景
假设存在A/B函数相互关联，A函数每次一次正向操作，B函数必然会执行一次反向操作，A/B函数保证相关抵消。
那么考虑以下场景:

ABABABABABABABABABABABABAB

## 目标
A/B函数高频率触发，但是最终效果都是抵消的，此时如果基于用户交互优化，以及节约性能的考虑，可以进行约束节流。
不改变最终的效果，但是可以减少触发次数。

优化效果可能如下：

A----------B----------A------------B

遇到这种问题，机智的我尝试写了个函数，实现了大致效果，源码地址：[BT](https://github.com/soulizs/BT/blob/master/src/index.js)

![database](https://user-gold-cdn.xitu.io/2019/6/7/16b31eae43cf9f24?w=876&h=1198&f=png&s=484192)

上图中所示，如果不做优化，基本上每一行都会执行真正的A/B函数逻辑（以/SKIP/、/DONE/标记开头的那些，/SHOW/是为了展示那个时间点的数据库结果）。

图中示例是以300ms进行约束节流的，优化后，**图中白色和红色那些行即为真正执行的A/B函数逻辑**

## 实现原理
通过计数器来记录A/B函数执行次数，同时利用时间戳和定时器，判断A函数执行后，在节流时间内将多余的A函数略过，同时最大控制B函数在节流时间的末尾执行。
```js
count: 0, // 平衡值，最终所有A/B函数执行完后，确保count === 0
ctime: 0, // 每次执行真的A函数开始后的触发时间
F_callTimes: 0, // A函数（无论真假）执行次数
B_callTimes: 0, // B函数（无论真假）执行次数
```

为了确保不出错，在定时器里通过判断A/B函数执行次数，始终确保两个函数执行次数相一致。

```js
timeRef.unset().set(() => {
  const delta = F_callTimes - B_callTimes;
  for (let i = 0; i <= delta; i++) {
    wrapperB(...args);  // 执行B包裹函数
  }
}, idleness);
```

有同学看到了**无论真假**，肯定满脸问号。

是这样的，真的A/B函数就是真的业务逻辑，可能会带有各种副作用，消耗性能等。而假的A/B函数，就是替换真的A/B函数而存在的，可以用来打印日志等等。

## 优化
在开发这个BT过程中，遇到了一个问题，如果A/B函数，传参不同的话，那么很明显是用来执行不同操作的，此时需要进行**分类约束节流**。这个简单可以通过一个对象记录分类。

```js
function generateRecord(type) {
  BTRecrod[type] = {
    count: 0,
    ctime: 0,
    F_callTimes: 0,
    B_callTimes: 0,
    timeRef: Object.assign({}, timeout)
  };
}
```

而type就是分类的依据，那怎么生成呢？通过参数拼接一下，就得到不同的type。这里简单只做了原始值类型的处理，如果是对象的话，可以深度遍历一下去计算生成不一样的type~
```js
export function generateType(...args) {
  return ["BT"].concat(args).join("_");
}
```

至此，还有一个问题没有处理，如果A/B函数是异步的怎么办？可能需要等待A/B函数异步返回成功的时候，才能算做执行成功...

## 使用
最终调用效果如下：
```js
import { BT } from "binary-throttle";
 
function forward() {
  // @TODO
}
 
function backward() {
  // @TODO
}
 
const [X, Y] = BT(forward, backward, {
  // idleness: 300,
  // fallbackF: () => console.log('X was ignore this time.'),
  // fallbackB: () => console.log('Y was ignore this time.')
});
```

接下来无论forward，backward函数交换调用多么频繁，经过BT的约束节流处理后，都只会大大减少调用次数，但是最终结果还是一致的。

## 小结
这个函数我已经发了个包名叫`binary-throttle`，还是不推荐大家使用（因为），写出来纯粹是交个朋友😏，给大家提供点思路，顺便自己也记录一下~

这种场景可能比较少见，不过不影响大家感兴趣可以戳戳： [BT](https://www.npmjs.com/package/binary-throttle)

（如果有同学好奇去搜，很有可能**双函数约束节流**这个名词就是不存在，我瞎编的哈哈哈哈...）